---
title: "Conceitos"
---

```{r, message=FALSE, warning=FALSE, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, 
  out.width = "60%", out.height = "60%",
  fig.retina = 2
)
```

## Começando com um exemplo

Um aplicativo em `shiny` (ou `shiny app`) é composto por duas partes:

- Um script `ui.R`, que constrói a interface que o usuário enxerga e interage;
- Um script `server.R`, que descreve o código em R que roda por trás da `user-interface`. 

Um exemplo de app com essa estrutura pode ser visualizado rodando o comando abaixo. (Para voltar ao R feche a janela ou pressine Esc no console):

```{r eval=FALSE}
shiny::runExample('01_hello')
```

Nesse primeiro exemplo, o arquivo `ui.R` é bastante simples, mas ilustra a estrutura básica de um arquivo desse tipo.

```{r ui_file, eval = FALSE}
library(shiny)

# Define a User-Interface da aplicação
shinyUI(fluidPage(
  # Título da aplicação
  titlePanel("Hello Shiny!"),

  # Sidebar com um slider para o número de colunas
  sidebarLayout(
    sidebarPanel(
      sliderInput("bins",
                  "Number of bins:",
                  min = 1,
                  max = 50,
                  value = 30)
    ),

    # Imprime o plot
    mainPanel(
      plotOutput("distPlot")
    )
  )
))
```

Todo arquivo `ui` tem uma composição parecida com a identificada acima:

- Todo o código, com exceção do `library(shiny)`, está envolto em uma aplicação da função `shinyUI`.
    - Dentro do `shinyUI`, todo código está envolto em uma função que define o layout da aplicação. No exemplo anterior, `fluidPage` faz esse papel. Existem outras opções que serão detalhadas mais adiante.
      - Dentro da definição do layout vem o conteúdo da página.

```{r serve, eval = FALSE}

library(shiny)

# Define a lógica necessária pra criar o histograma
shinyServer(function(input, output) {

  # Expressão que gera o histograma. A expressão é 
  # escrita dentro de um "renderPlot" para garantir
  # duas coisas:
  #
  #  1) A expressão é "reactive" e por isso será atualizada
  # automaticamente após a mudança de um input.
  #  2) Seu tipo de output é um plot.

  output$distPlot <- renderPlot({
    x    <- faithful[, 2]  # Old Faithful Geyser data
    bins <- seq(min(x), max(x), length.out = input$bins + 1)

    # Desenha o histograma com um determinado número de bins.
    hist(x, breaks = bins, col = 'darkgray', border = 'white')
  })
})

```

É interessante notar que o código não fornece nenhum parâmetro gráfico para o navegador, tal como o conteúdo de um arquivo `css`. O Shiny utiliza como padrão o estilo [bootstrap css](http://getbootstrap.com/css/) do [Twitter](https://twitter.com), que é bonito e responsivo (lida bem com várias plataformas, como notebook e mobile). Não é necessário descrever com detalhes o site que será construído, apenas os `inputs` e `outputs`.

Para estudar os *widgets* (entradas de dados para o usuário), acesse [este link](http://shiny.rstudio.com/gallery/widget-gallery.html 'widgets') ou rode

```{r eval=FALSE}
shiny::runGitHub('garrettgman/shinyWidgets')
```

## Criando outputs

Imagine que para cada função `xxOutput('foo', ...)` do `ui.R` você pode colocar um código do tipo `output$foo <- renderXX(...)` no `server.R`. A função no arquivo `ui.R` determina a localização e identificação do elemento. Crie gráficos com `plotOutput` e `renderPlot` e exiba dados com `dataTableOutput` e `renderDataTable`.

## Fazendo mais com o shiny

### Shiny Server Pro

- Licença comercial do Shiny-server
- Possui algumas características a mais, como autenticação e suporte.

### shinyapps.io

- Para compartilhar um aplicativo shiny, geralmente precisamos ter um servidor Linux (geralmente utilizando algum serviço na cloud como AWS ou DigitalOcean) com o shiny server instalado.
- Isso pode ser doloroso.
- O shinyapps.io é um sistema (que envolve tanto pacote do R como uma página web) que permite que o usuário coloque sua aplicação shiny na web sem muito esforço.
- O serviço foi desenvolvido pela RStudio Inc. e possui contas grátis e pagas.

### Flexdashboards

(na outra página)
